# lab1
>>通过本实验了解到用户级的应用程序是怎么获得内核数据的。总体思路就是在应用程序中调用

系统调用函数，而系统调用是给用户程序的接口，可以通过使用系统调用返回所需要的参数，来完成

在空间隔离的情况下获取自己用户级别无法获取的内核数据。

几个程序的宏观上的思路都是在程序中使用系统调用来完成函数功能
## sleep
>>这个实验内容很简单，仅仅就是从shell获取参数，然后将参数传给系统调用的sleep函数，相对没什么难度
## find
>> 实验难点在于对目录的操作，怎么获取目录每一部分的内容。第一个参数为目录，第二个参数为目标文件

思路为去遍历这个目录下的内容，若类型为文件，则判断与目标文件是否相同。若类型为目录，则递归调用find函数

搜索此子目录。
## primes
>> 很神奇的一个实验，该实验内容是为了熟悉pipe的操作。但是这种使用pipe的形式确实从来没有想过，虽然写过不少递归的

函数，但从来没想过pipe可以去递归。但想想fork可以复制文件描述符，又是完全可以实现的。提供的那个算法刚开始没看懂是

什么意思。不过看了些博客也清楚了。在一个进程里去读管道内容，判断是否为质数，若后续值除以当前值余数为0，则不是质数，没有

必要传到下一个管道中。难点在于对与管道的控制，怎么从一个管道到另一个管道，什么时候关闭读端，什么时候关闭写端。当然刚开始

的想法肯定是中间那么多管道，管理肯定很麻烦，我可以在进程所有操作结束后再统一去关闭。但问题在于，管道在read时，若写端没有关闭，

读读端的时候，read会一直阻塞，这样就出现了问题。并且文件描述符的数量是有限的，总会到某个子进程，此时文件描述符达到最大值，则无法再

创建管道，递归就会出问题。
## 
